var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _class, _temp, _initialiseProps;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

import React from "react";
import classnames from "classnames";
import viewport from "viewport-size";
import Portal from "react-portal";
import PropTypes from 'prop-types';

var ImageZoom = (_temp = _class = function (_React$Component) {
  _inherits(ImageZoom, _React$Component);

  function ImageZoom(props) {
    _classCallCheck(this, ImageZoom);

    var _this = _possibleConstructorReturn(this, _React$Component.call(this, props));

    _initialiseProps.call(_this);

    _this.state = {
      loading: false,
      showClone: false,
      zoomedIn: false
    };
    return _this;
  }

  ImageZoom.prototype.componentWillUpdate = function componentWillUpdate(nextProps, nextState) {
    var isZoomingIn = this.getZoomedInState(nextProps, nextState);
    var isZoomedIn = this.getZoomedInState(this.props, this.state);

    // Bind event listeners if zooming in
    if (isZoomingIn && !isZoomedIn) {
      this.bindDocumentListeners();

      // Unbind event listeners if zooming out
    } else if (!isZoomingIn && isZoomedIn) {
      this.unbindDocumentListeners();
    }
  };

  ImageZoom.prototype.bindDocumentListeners = function bindDocumentListeners() {
    document.addEventListener("click", this.hide);
  };

  ImageZoom.prototype.unbindDocumentListeners = function unbindDocumentListeners() {
    document.removeEventListener("click", this.hide);
  };

  ImageZoom.prototype.render = function render() {
    var _this2 = this;

    var child = React.Children.only(this.props.children);
    var original = React.cloneElement(child, {
      ref: function ref(image) {
        return _this2.thumb = image;
      },
      onClick: this.onClickThumbnail,
      className: classnames(child.className, this.state.loading && "image-zoom-loading"),
      style: _extends({}, child.props.style, {
        opacity: this.state.showClone ? 0 : 1,
        cursor: "zoom-in"
      })
    });

    var zoomedIn = this.getZoomedInState(this.props, this.state);
    var loading = this.state.loading;


    var clonedDimensions = !loading ? this.getClonedDimensions() : {};

    var clone = React.cloneElement(child, {
      style: _extends({
        position: "fixed",
        cursor: "zoom-out",
        transition: "all " + this.props.duration + "ms ease"
      }, clonedDimensions)
    });

    return React.createElement(
      "span",
      { style: { position: "relative" } },
      React.createElement(
        Portal,
        { isOpened: this.state.showClone },
        React.createElement(
          "div",
          null,
          this.props.overlay && React.createElement(
            "div",
            {
              style: {
                position: "fixed",
                top: 0,
                left: 0,
                right: 0,
                bottom: 0,
                background: "rgba(255,255,255,0.95)",
                opacity: zoomedIn ? 1 : 0,
                transition: "opacity " + this.props.duration + "ms ease"
              }
            },
            this.props.closeButton && React.createElement(
              "button",
              {
                onClick: this.hide,
                style: {
                  padding: 0,
                  position: "fixed",
                  top: "15px",
                  right: "15px",
                  cursor: "pointer",
                  background: "transparent",
                  border: 0,
                  webkitAppearance: "none"
                }
              },
              React.createElement(
                "span",
                {
                  "aria-hidden": "true",
                  style: {
                    fontSize: "20px",
                    fontWeight: 300,
                    color: "black",
                    fontFamily: "sans-serif"
                  }
                },
                "x"
              )
            )
          ),
          clone
        )
      ),
      loading && this.props.loader,
      original
    );
  };

  return ImageZoom;
}(React.Component), _class.defaultProps = {
  padding: 0,
  duration: 300,
  loader: null,
  overlay: true,
  closeButton: false
}, _initialiseProps = function _initialiseProps() {
  var _this3 = this;

  this.getZoomedInState = function (props, state) {
    return props.onZoomToggle ? props.zoomedIn : state.zoomedIn;
  };

  this.setZoomedInState = function (zoomedIn) {
    _this3.props.onZoomToggle ? _this3.props.onZoomToggle(zoomedIn) : _this3.setState({ zoomedIn: zoomedIn });
  };

  this.hide = function () {
    _this3.zoomOut();
    _this3.hideTimer = setTimeout(function () {
      _this3.setState({ showClone: false });
    }, _this3.props.duration);
  };

  this.onClickThumbnail = function (e) {
    e.preventDefault();
    _this3.zoomIn();
  };

  this.loadImage = function (src, fn) {
    if (_this3.image) {
      return fn(_this3.image);
    }
    _this3.setState({ loading: true, error: false });
    var img = _this3.image = new Image();
    img.onload = function () {
      _this3.setState({ loading: false, error: false });
      return fn(_this3.image);
    };
    img.onerror = function (err) {
      console.log("Error loading full-size image: ", err);
      _this3.setState({ error: true });
    };
    img.src = src;
  };

  this.zoomIn = function () {
    if (_this3.hideTimer) {
      clearTimeout(_this3.hideTimer);
    }
    var child = React.Children.only(_this3.props.children);
    var fullSizeURL = _this3.props.zoomedInURL || child.props.src;
    if (!fullSizeURL) {
      throw new Error("No full size image URL provided.");
    }
    _this3.loadImage(fullSizeURL, function (img) {
      _this3.setState({ showClone: true }, function () {
        _this3.setZoomedInState(true);
      });
    });
  };

  this.getClonedDimensions = function () {
    if (!_this3.image) return {};
    var o = _this3.determineOriginDimensions();
    var t = _this3.determineTargetDimensions(_this3.image);
    var zoomedIn = _this3.getZoomedInState(_this3.props, _this3.state);
    var showClone = _this3.state.showClone;


    var clonedPosition = {
      left: t.x + "px",
      top: t.y + "px",
      width: t.w + "px",
      height: t.h + "px"
    };

    // replica state
    if (!_this3.state.showClone || !zoomedIn) {
      var scale = o.w / t.w;
      var translateX = o.x + o.w / 2 - (t.x + t.w / 2);
      var translateY = o.y + o.h / 2 - (t.y + t.h / 2);
      return _extends({}, clonedPosition, {
        transform: "translateX(" + translateX + "px) translateY(" + translateY + "px) scale(" + scale + ")"
      });
    }

    // final zoomed in state
    return _extends({}, clonedPosition, {
      transform: "translateX(0) translateY(0) scale(1)"
    });
  };

  this.zoomOut = function () {
    _this3.setZoomedInState(false);
  };

  this.determineOriginDimensions = function () {
    var pos = _this3.thumb.getBoundingClientRect();
    var origin = {
      x: pos.left,
      y: pos.top,
      w: _this3.thumb.clientWidth,
      h: _this3.thumb.clientHeight
    };
    return origin;
  };

  this.determineTargetDimensions = function (image) {
    var iw = image.width;
    var ih = image.height;
    var vph = viewport.getHeight();
    var vpw = viewport.getWidth();

    // zoomed image max size
    var target = scaleToBounds(iw, ih, vpw - _this3.props.padding, vph - _this3.props.padding);

    // determine left and top position of zoomed image
    var left = vpw / 2 - target.width / 2;
    var top = vph / 2 - target.height / 2;

    return {
      x: left,
      y: top,
      w: target.width,
      h: target.height
    };
  };
}, _temp);
process.env.NODE_ENV !== "production" ? ImageZoom.propTypes = {
  zoomedIn: PropTypes.bool,
  onZoomToggle: PropTypes.func,
  zoomedInURL: PropTypes.string,
  padding: PropTypes.number,
  duration: PropTypes.number,
  loader: PropTypes.node,
  overlay: PropTypes.bool,
  closeButton: PropTypes.bool
} : void 0;


export default ImageZoom;

/**
 * Return the maximum size given a set of bounds
 * while maintaining the original aspect ratio.
 * @param  {Number} ow original width
 * @param  {Number} oh original height
 * @param  {Number} mw max width
 * @param  {Number} mh max height
 * @return {Object}
 */

function scaleToBounds(ow, oh, mw, mh) {
  var scale = Math.min(mw / ow, mh / oh);
  if (scale > 1) scale = 1;
  return {
    width: ow * scale,
    height: oh * scale
  };
}